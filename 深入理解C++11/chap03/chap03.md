## chap03 通用为本，专用为末 81/336

+ 3.1 继承构造函数
	+ **基类的非虚函数则无法再被派生类使用**。
	+ 如果派生类要使用基类的构造函数，通常需要在构造函数中显式声明。
		+ ```struct A{A(int i){}};   struct B:A{B(int i):A(i){}};```
	+ 基类只有一个构造函数 [3-1-1.cpp]()
	+ 基类有多个构造函数 [3-1-2.cpp]()
	+ 通过using声明[3-1-3.cpp]()
	+ 改造3-1-2.cpp [3-1-4.cpp]()
	+ **C++11标准继承构造函数被设计为跟派生类中的各种类默认函数（默认构造、析构、拷贝构造等）一样，都是隐式声明的**。
	+ 同时使用继承构造函数和成员变量初始化两个C++11的特性[3-1-5.cpp]()
	+ 对于继承构造函数来讲，参数的默认值是不会被继承的。[3-1-6.cpp]()  **参数默认值会导致多个构造函数版本的产生**
	+ 继承函数“冲突”的情况 [3-1-7.cpp]()
	+ [3-1-8.cpp]

+ 3.2 委派构造函数  86/336
	+ 重复代码的构造函数 [3-2-1.cpp]()
	+ C++11的写法[3-2-2.cpp]()
	+ C++11调用基准版本的构造函数[3-2-3.cpp]()
    + **委派构造函数（delegating constructor）**就是指委派函数将构造的任务委派给了目标构造函数（“基准版本”）来完成这样一种类构造的方式。
	+ **在C++中，构造函数不能同时“委派”和使用初始化列表，所以委派构造函数要给变量赋初值，初始化代码必须放在函数体中**。
	+ [3-2-4.cpp]
	+ **链状委托构造** [3-2-5.cpp]()
	+ 委派构造一个很实际的应用就是使用构造函数产生目标构造函数。 [3-2-6.cpp]()
	+ 在委派构造函数中使用try [3-2-7.cpp]()

+ 3.3 右值引用：移动语义和完美转发  92/336

+ 3.6 POD类型  124/336
	+ C++11将POD（Plain Old Data）划分为
		+ 平凡的（trivial）
		+ 标准布局的（standard layout）
	+ [3-6-1.cpp]





