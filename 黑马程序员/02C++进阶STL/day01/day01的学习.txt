01、  15min

从函数重载（int,float）的swap，讲到了函数模板，自动类型推导和显式指定。

显式指定，在调用时写成 “MySwap<int>(a,b)” ，**这个我还不太会**


02、 12min 

相同匹配项时，优先调用普通函数； 指定模板函数的语法是"MyAdd<>(a,b)"


03、  5min

C++的编译过程（理论）


04、  8min

C++的编译过程（实践）

-ESc参数，对应的过程   g++ index.s -o index  【是链接过程】


05、17min

两次编译过程
一次是函数模板的语法检查；一次根据具体的调用，再编译生成相应的模板函数
-S 生成 index.s文件，看汇编格式

06、7min

类模板必须显式指定类型 Person<int>

07、 11min
写的例子，但自已写的过程中会在前面忘记写template

08、

09、8min
cpp和h分离实现

10、6min
类内实现


12、16min+12min  【第2个12min讲的是  模板类中使用友元 】  --反正我是没有编译过
 
类模板 类外实现，都需要template<typename T>

Person<T>::Person()  // 一定要<T>，这样才能实例化，一个具体的类  //invalid use of template-name 'Person' without an argument list|

重载 左移操作符 实现

模板类中使用友元 还是有点麻烦的；   【结论：就是不要滥用友元】


13、20min
模板机制和C++编译机制 相关 （类外只有引入.cpp）才行，引入.h不行

C++对每个cpp进行独立编译；【发现一个函数调用，在当前文件找不到，在函数位置生成符号，让链接器去找】，所以单个是通过的，链接时找不到会报错。

函数模板会进行2次编译（第1次只是编译模板，只有第2次，在调用时才生成具体的函数）

main.cpp  包括头文件，编译不生成，show()方法找不到，让链接器函数具体实现
day01_e13.cpp 编译时，函数模板，只是进行了第1次编译，根据具体的使用，才编译【但没有触发2次编译，所以main找不到具体函数】



14、4min
把#include".h"改成".cpp"


15、11min
类模板中的 static对象属于 具体类自已的




